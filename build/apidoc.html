<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api-documentation for
    <a
        
        href="https://github.com/node-schedule/node-schedule#readme"
        
    >node-schedule (v1.2.1)</a>
</h1>
<h4>A cron-like and not-cron-like job scheduler for Node.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule">module node-schedule</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Invocation">
            function <span class="apidocSignatureSpan">node-schedule.</span>Invocation
            <span class="apidocSignatureSpan">(job, fireDate, recurrenceRule, endDate)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Job">
            function <span class="apidocSignatureSpan">node-schedule.</span>Job
            <span class="apidocSignatureSpan">(name, job, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Range">
            function <span class="apidocSignatureSpan">node-schedule.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.RecurrenceRule">
            function <span class="apidocSignatureSpan">node-schedule.</span>RecurrenceRule
            <span class="apidocSignatureSpan">(year, month, date, dayOfWeek, hour, minute, second)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.cancelJob">
            function <span class="apidocSignatureSpan">node-schedule.</span>cancelJob
            <span class="apidocSignatureSpan">(job)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.rescheduleJob">
            function <span class="apidocSignatureSpan">node-schedule.</span>rescheduleJob
            <span class="apidocSignatureSpan">(job, spec)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.scheduleJob">
            function <span class="apidocSignatureSpan">node-schedule.</span>scheduleJob
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-schedule.</span>Job.prototype</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-schedule.</span>Range.prototype</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-schedule.</span>RecurrenceRule.prototype</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-schedule.</span>scheduledJobs</span>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule.Job">module node-schedule.Job</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Job.Job">
            function <span class="apidocSignatureSpan">node-schedule.</span>Job
            <span class="apidocSignatureSpan">(name, job, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Job.super_">
            function <span class="apidocSignatureSpan">node-schedule.Job.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule.Job.prototype">module node-schedule.Job.prototype</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Job.prototype.invoke">
            function <span class="apidocSignatureSpan">node-schedule.Job.prototype.</span>invoke
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Job.prototype.runOnDate">
            function <span class="apidocSignatureSpan">node-schedule.Job.prototype.</span>runOnDate
            <span class="apidocSignatureSpan">(date)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Job.prototype.schedule">
            function <span class="apidocSignatureSpan">node-schedule.Job.prototype.</span>schedule
            <span class="apidocSignatureSpan">(spec)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule.Range">module node-schedule.Range</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Range.Range">
            function <span class="apidocSignatureSpan">node-schedule.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule.Range.prototype">module node-schedule.Range.prototype</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.Range.prototype.contains">
            function <span class="apidocSignatureSpan">node-schedule.Range.prototype.</span>contains
            <span class="apidocSignatureSpan">(val)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule.RecurrenceRule">module node-schedule.RecurrenceRule</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.RecurrenceRule.RecurrenceRule">
            function <span class="apidocSignatureSpan">node-schedule.</span>RecurrenceRule
            <span class="apidocSignatureSpan">(year, month, date, dayOfWeek, hour, minute, second)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.node-schedule.RecurrenceRule.prototype">module node-schedule.RecurrenceRule.prototype</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.node-schedule.RecurrenceRule.prototype.nextInvocationDate">
            function <span class="apidocSignatureSpan">node-schedule.RecurrenceRule.prototype.</span>nextInvocationDate
            <span class="apidocSignatureSpan">(base)</span>
            </a>
            
        </li>
        
    </ol></li>
    
</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule" id="apidoc.module.node-schedule">module node-schedule</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Invocation" id="apidoc.element.node-schedule.Invocation">
        function <span class="apidocSignatureSpan">node-schedule.</span>Invocation
        <span class="apidocSignatureSpan">(job, fireDate, recurrenceRule, endDate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Invocation(job, fireDate, recurrenceRule, endDate) {
  this.job = job;
  this.fireDate = fireDate;
  this.endDate = endDate;
  this.recurrenceRule = recurrenceRule || DoesntRecur;

  this.timerID = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Job" id="apidoc.element.node-schedule.Job">
        function <span class="apidocSignatureSpan">node-schedule.</span>Job
        <span class="apidocSignatureSpan">(name, job, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Job(name, job, callback) {
  // setup a private pendingInvocations variable
  var pendingInvocations = [];

  //setup a private number of invocations variable
  var triggeredJobs = 0;

  // Set scope vars
  var jobName = name &#x26;&#x26; typeof name === &#x27;string&#x27; ? name : &#x27;&#x3c;Anonymous Job &#x27; + (++anonJobCounter) + &#x27;&#x3e;&#x27;;
  this.job = name &#x26;&#x26; typeof name === &#x27;function&#x27; ? name : job;

  // Make sure callback is actually a callback
  if (this.job === name) {
    // Name wasn&#x27;t provided and maybe a callback is there
    this.callback = typeof job === &#x27;function&#x27; ? job : false;
  } else {
    // Name was provided, and maybe a callback is there
    this.callback = typeof callback === &#x27;function&#x27; ? callback : false;
  }

  // Check for generator
  if (typeof this.job === &#x27;function&#x27; &#x26;&#x26;
      this.job.prototype &#x26;&#x26;
      this.job.prototype.next) {
    this.job = function() {
      return this.next().value;
    }.bind(this.job.call(this));
  }

  // define properties
  Object.defineProperty(this, &#x27;name&#x27;, {
    value: jobName,
    writable: false,
    enumerable: true
  });

  // method that require private access
  this.trackInvocation = function(invocation) {
    // add to our invocation list
    sorted.add(pendingInvocations, invocation, sorter);
    return true;
  };
  this.stopTrackingInvocation = function(invocation) {
    var invIdx = pendingInvocations.indexOf(invocation);
    if (invIdx &#x3e; -1) {
      pendingInvocations.splice(invIdx, 1);
      return true;
    }

    return false;
  };
  this.triggeredJobs = function() {
    return triggeredJobs;
  };
  this.setTriggeredJobs = function(triggeredJob) {
    triggeredJobs = triggeredJob;
  };
  this.cancel = function(reschedule) {
    reschedule = (typeof reschedule == &#x27;boolean&#x27;) ? reschedule : false;

    var inv, newInv;
    var newInvs = [];
    for (var j = 0; j &#x3c; pendingInvocations.length; j++) {
      inv = pendingInvocations[j];

      cancelInvocation(inv);

      if (reschedule &#x26;&#x26; inv.recurrenceRule.recurs) {
        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);
        if (newInv !== null) {
          newInvs.push(newInv);
        }
      }
    }

    pendingInvocations = [];

    for (var k = 0; k &#x3c; newInvs.length; k++) {
      this.trackInvocation(newInvs[k]);
    }

    // remove from scheduledJobs if reschedule === false
    if (!reschedule) {
      if (this.name) {
        delete scheduledJobs[this.name];
      }
    }

    return true;
  };
  this.cancelNext = function(reschedule) {
    reschedule = (typeof reschedule == &#x27;boolean&#x27;) ? reschedule : true;

    if (!pendingInvocations.length) {
      return false;
    }

    var newInv;
    var nextInv = pendingInvocations.shift();

    cancelInvocation(nextInv);

    if (reschedule &#x26;&#x26; nextInv.recurrenceRule.recurs) {
      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);
      if (newInv !== null) {
        this.trackInvocation(newInv);
      }
    }

    return true;
  };
  this.reschedule = function(spec) {
    var inv;
    var cInvs = pendingInvocations.slice();

    for (var j = 0; j &#x3c; cInvs.length; j++) {
      inv = cInvs[j];

      cancelInvocation(inv);
    }

    pendingInvocations = [];

    if (this.schedule(spec)) {
      this.setTriggeredJobs(0);
      return true;
    } else {
      pendingInvocations = cInvs;
      return false;
    }
  };
  this.nextInvocation = function() {
    if (!pendingInvocations.length) {
      return null;
    }
    return pendingInvocations[0].fireDate;
  };
  this.pendingInvocations = function() {
    return pendingInvocations;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Range" id="apidoc.element.node-schedule.Range">
        function <span class="apidocSignatureSpan">node-schedule.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  this.start = start || 0;
  this.end = end || 60;
  this.step = step || 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can also use arrays to specify a list of acceptable values, and the `Range`
object to specify a range of start and end values, with an optional step parameter.
For instance, this will print a message on Thursday, Friday, Saturday, and Sunday at 5pm:

```js
var rule = new schedule.RecurrenceRule();
rule.dayOfWeek = [0, new schedule.<span class="apidocCodeKeywordSpan">Range</span>(4, 6)];
rule.hour = 17;
rule.minute = 0;

var j = schedule.scheduleJob(rule, function(){
  console.log(&#x27;Today is recognized by Rebecca Black!&#x27;);
});
```
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.RecurrenceRule" id="apidoc.element.node-schedule.RecurrenceRule">
        function <span class="apidocSignatureSpan">node-schedule.</span>RecurrenceRule
        <span class="apidocSignatureSpan">(year, month, date, dayOfWeek, hour, minute, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {
  this.recurs = true;

  this.year = (year == null) ? null : year;
  this.month = (month == null) ? null : month;
  this.date = (date == null) ? null : date;
  this.dayOfWeek = (dayOfWeek == null) ? null : dayOfWeek;
  this.hour = (hour == null) ? null : hour;
  this.minute = (minute == null) ? null : minute;
  this.second = (second == null) ? 0 : second;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can build recurrence rules to specify when a job should recur. For instance,
consider this rule, which executes the function every hour at 42 minutes after the hour:

```js
var schedule = require(&#x27;node-schedule&#x27;);

var rule = new schedule.<span class="apidocCodeKeywordSpan">RecurrenceRule</span>();
rule.minute = 42;

var j = schedule.scheduleJob(rule, function(){
  console.log(&#x27;The answer to life, the universe, and everything!&#x27;);
});
```
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.cancelJob" id="apidoc.element.node-schedule.cancelJob">
        function <span class="apidocSignatureSpan">node-schedule.</span>cancelJob
        <span class="apidocSignatureSpan">(job)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cancelJob(job) {
  var success = false;
  if (job instanceof Job) {
    success = job.cancel();
  } else if (typeof job == &#x27;string&#x27; || job instanceof String) {
    if (job in scheduledJobs &#x26;&#x26; scheduledJobs.hasOwnProperty(job)) {
      success = scheduledJobs[job].cancel();
    }
  }

  return success;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.rescheduleJob" id="apidoc.element.node-schedule.rescheduleJob">
        function <span class="apidocSignatureSpan">node-schedule.</span>rescheduleJob
        <span class="apidocSignatureSpan">(job, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rescheduleJob(job, spec) {
  if (job instanceof Job) {
    if (job.reschedule(spec)) {
      return job;
    }
  } else if (typeof job == &#x27;string&#x27; || job instanceof String) {
    if (job in scheduledJobs &#x26;&#x26; scheduledJobs.hasOwnProperty(job)) {
      if (scheduledJobs[job].reschedule(spec)) {
        return scheduledJobs[job];
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.scheduleJob" id="apidoc.element.node-schedule.scheduleJob">
        function <span class="apidocSignatureSpan">node-schedule.</span>scheduleJob
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scheduleJob() {
  if (arguments.length &#x3c; 2) {
    return null;
  }

  var name = (arguments.length &#x3e;= 3 &#x26;&#x26; typeof arguments[0] === &#x27;string&#x27;) ? arguments[0] : null;
  var spec = name ? arguments[1] : arguments[0];
  var method = name ? arguments[2] : arguments[1];
  var callback = name ? arguments[3] : arguments[2];

  var job = new Job(name, method, callback);

  if (job.schedule(spec)) {
    return job;
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Examples with the cron format:

```js
var schedule = require(&#x27;node-schedule&#x27;);

var j = schedule.<span class="apidocCodeKeywordSpan">scheduleJob</span>(&#x27;42 * * * *&#x27;, function(){
  console.log(&#x27;The answer to life, the universe, and everything!&#x27;);
});
```

Execute a cron job when the minute is 42 (e.g. 19:42, 20:42, etc.).

And:
...</pre></li>
    </ul>
    
    
    
    
    
    
    
    
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule.Job" id="apidoc.module.node-schedule.Job">module node-schedule.Job</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Job.Job" id="apidoc.element.node-schedule.Job.Job">
        function <span class="apidocSignatureSpan">node-schedule.</span>Job
        <span class="apidocSignatureSpan">(name, job, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Job(name, job, callback) {
  // setup a private pendingInvocations variable
  var pendingInvocations = [];

  //setup a private number of invocations variable
  var triggeredJobs = 0;

  // Set scope vars
  var jobName = name &#x26;&#x26; typeof name === &#x27;string&#x27; ? name : &#x27;&#x3c;Anonymous Job &#x27; + (++anonJobCounter) + &#x27;&#x3e;&#x27;;
  this.job = name &#x26;&#x26; typeof name === &#x27;function&#x27; ? name : job;

  // Make sure callback is actually a callback
  if (this.job === name) {
    // Name wasn&#x27;t provided and maybe a callback is there
    this.callback = typeof job === &#x27;function&#x27; ? job : false;
  } else {
    // Name was provided, and maybe a callback is there
    this.callback = typeof callback === &#x27;function&#x27; ? callback : false;
  }

  // Check for generator
  if (typeof this.job === &#x27;function&#x27; &#x26;&#x26;
      this.job.prototype &#x26;&#x26;
      this.job.prototype.next) {
    this.job = function() {
      return this.next().value;
    }.bind(this.job.call(this));
  }

  // define properties
  Object.defineProperty(this, &#x27;name&#x27;, {
    value: jobName,
    writable: false,
    enumerable: true
  });

  // method that require private access
  this.trackInvocation = function(invocation) {
    // add to our invocation list
    sorted.add(pendingInvocations, invocation, sorter);
    return true;
  };
  this.stopTrackingInvocation = function(invocation) {
    var invIdx = pendingInvocations.indexOf(invocation);
    if (invIdx &#x3e; -1) {
      pendingInvocations.splice(invIdx, 1);
      return true;
    }

    return false;
  };
  this.triggeredJobs = function() {
    return triggeredJobs;
  };
  this.setTriggeredJobs = function(triggeredJob) {
    triggeredJobs = triggeredJob;
  };
  this.cancel = function(reschedule) {
    reschedule = (typeof reschedule == &#x27;boolean&#x27;) ? reschedule : false;

    var inv, newInv;
    var newInvs = [];
    for (var j = 0; j &#x3c; pendingInvocations.length; j++) {
      inv = pendingInvocations[j];

      cancelInvocation(inv);

      if (reschedule &#x26;&#x26; inv.recurrenceRule.recurs) {
        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);
        if (newInv !== null) {
          newInvs.push(newInv);
        }
      }
    }

    pendingInvocations = [];

    for (var k = 0; k &#x3c; newInvs.length; k++) {
      this.trackInvocation(newInvs[k]);
    }

    // remove from scheduledJobs if reschedule === false
    if (!reschedule) {
      if (this.name) {
        delete scheduledJobs[this.name];
      }
    }

    return true;
  };
  this.cancelNext = function(reschedule) {
    reschedule = (typeof reschedule == &#x27;boolean&#x27;) ? reschedule : true;

    if (!pendingInvocations.length) {
      return false;
    }

    var newInv;
    var nextInv = pendingInvocations.shift();

    cancelInvocation(nextInv);

    if (reschedule &#x26;&#x26; nextInv.recurrenceRule.recurs) {
      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);
      if (newInv !== null) {
        this.trackInvocation(newInv);
      }
    }

    return true;
  };
  this.reschedule = function(spec) {
    var inv;
    var cInvs = pendingInvocations.slice();

    for (var j = 0; j &#x3c; cInvs.length; j++) {
      inv = cInvs[j];

      cancelInvocation(inv);
    }

    pendingInvocations = [];

    if (this.schedule(spec)) {
      this.setTriggeredJobs(0);
      return true;
    } else {
      pendingInvocations = cInvs;
      return false;
    }
  };
  this.nextInvocation = function() {
    if (!pendingInvocations.length) {
      return null;
    }
    return pendingInvocations[0].fireDate;
  };
  this.pendingInvocations = function() {
    return pendingInvocations;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Job.super_" id="apidoc.element.node-schedule.Job.super_">
        function <span class="apidocSignatureSpan">node-schedule.Job.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule.Job.prototype" id="apidoc.module.node-schedule.Job.prototype">module node-schedule.Job.prototype</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Job.prototype.invoke" id="apidoc.element.node-schedule.Job.prototype.invoke">
        function <span class="apidocSignatureSpan">node-schedule.Job.prototype.</span>invoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invoke = function () {
  if (typeof this.job == &#x27;function&#x27;) {
    this.setTriggeredJobs(this.triggeredJobs() + 1);
    this.job();
  } else {
    this.job.execute();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Job.prototype.runOnDate" id="apidoc.element.node-schedule.Job.prototype.runOnDate">
        function <span class="apidocSignatureSpan">node-schedule.Job.prototype.</span>runOnDate
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runOnDate = function (date) {
  return this.schedule(date);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Job.prototype.schedule" id="apidoc.element.node-schedule.Job.prototype.schedule">
        function <span class="apidocSignatureSpan">node-schedule.Job.prototype.</span>schedule
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedule = function (spec) {
  var self = this;
  var success = false;
  var inv;
  var start;
  var end;

  if (typeof spec === &#x27;object&#x27; &#x26;&#x26; spec.rule) {
    start = spec.start || null;
    end = spec.end || null;
    spec = spec.rule;

    if (start != null) {
      if (!(start instanceof Date)) {
        start = new Date(start);
      }
      if (!isValidDate(start) || start.getTime() &#x3c; Date.now()) {
        start = null;
      }
    }

    if (end != null &#x26;&#x26; !(end instanceof Date) &#x26;&#x26; !isValidDate(end = new Date(end))) {
      end = null;
    }
  }

  try {
    var res = cronParser.parseExpression(spec, { currentDate: start });
    inv = scheduleNextRecurrence(res, self, start, end);
    if (inv !== null) {
      success = self.trackInvocation(inv);
    }

  } catch (err) {
    var type = typeof spec;
    if ((type === &#x27;string&#x27;) || (type === &#x27;number&#x27;)) {
      spec = new Date(spec);
    }

    if ((spec instanceof Date) &#x26;&#x26; (isValidDate(spec))) {
      if (spec.getTime() &#x3e;= Date.now()) {
        inv = new Invocation(self, spec);
        scheduleInvocation(inv);
        success = self.trackInvocation(inv);
      }
    } else if (type === &#x27;object&#x27;) {
      if (!(spec instanceof RecurrenceRule)) {
        var r = new RecurrenceRule();
        if (&#x27;year&#x27; in spec) {
          r.year = spec.year;
        }
        if (&#x27;month&#x27; in spec) {
          r.month = spec.month;
        }
        if (&#x27;date&#x27; in spec) {
          r.date = spec.date;
        }
        if (&#x27;dayOfWeek&#x27; in spec) {
          r.dayOfWeek = spec.dayOfWeek;
        }
        if (&#x27;hour&#x27; in spec) {
          r.hour = spec.hour;
        }
        if (&#x27;minute&#x27; in spec) {
          r.minute = spec.minute;
        }
        if (&#x27;second&#x27; in spec) {
          r.second = spec.second;
        }

        spec = r;
      }

      inv = scheduleNextRecurrence(spec, self, start, end);
      if (inv !== null) {
        success = self.trackInvocation(inv);
      }
    }
  }

  scheduledJobs[this.name] = this;
  return success;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule.Range" id="apidoc.module.node-schedule.Range">module node-schedule.Range</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Range.Range" id="apidoc.element.node-schedule.Range.Range">
        function <span class="apidocSignatureSpan">node-schedule.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  this.start = start || 0;
  this.end = end || 60;
  this.step = step || 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can also use arrays to specify a list of acceptable values, and the `Range`
object to specify a range of start and end values, with an optional step parameter.
For instance, this will print a message on Thursday, Friday, Saturday, and Sunday at 5pm:

```js
var rule = new schedule.RecurrenceRule();
rule.dayOfWeek = [0, new schedule.<span class="apidocCodeKeywordSpan">Range</span>(4, 6)];
rule.hour = 17;
rule.minute = 0;

var j = schedule.scheduleJob(rule, function(){
  console.log(&#x27;Today is recognized by Rebecca Black!&#x27;);
});
```
...</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule.Range.prototype" id="apidoc.module.node-schedule.Range.prototype">module node-schedule.Range.prototype</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.Range.prototype.contains" id="apidoc.element.node-schedule.Range.prototype.contains">
        function <span class="apidocSignatureSpan">node-schedule.Range.prototype.</span>contains
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (val) {
  if (this.step === null || this.step === 1) {
    return (val &#x3e;= this.start &#x26;&#x26; val &#x3c;= this.end);
  } else {
    for (var i = this.start; i &#x3c; this.end; i += this.step) {
      if (i === val) {
        return true;
      }
    }

    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule.RecurrenceRule" id="apidoc.module.node-schedule.RecurrenceRule">module node-schedule.RecurrenceRule</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.RecurrenceRule.RecurrenceRule" id="apidoc.element.node-schedule.RecurrenceRule.RecurrenceRule">
        function <span class="apidocSignatureSpan">node-schedule.</span>RecurrenceRule
        <span class="apidocSignatureSpan">(year, month, date, dayOfWeek, hour, minute, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {
  this.recurs = true;

  this.year = (year == null) ? null : year;
  this.month = (month == null) ? null : month;
  this.date = (date == null) ? null : date;
  this.dayOfWeek = (dayOfWeek == null) ? null : dayOfWeek;
  this.hour = (hour == null) ? null : hour;
  this.minute = (minute == null) ? null : minute;
  this.second = (second == null) ? 0 : second;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can build recurrence rules to specify when a job should recur. For instance,
consider this rule, which executes the function every hour at 42 minutes after the hour:

```js
var schedule = require(&#x27;node-schedule&#x27;);

var rule = new schedule.<span class="apidocCodeKeywordSpan">RecurrenceRule</span>();
rule.minute = 42;

var j = schedule.scheduleJob(rule, function(){
  console.log(&#x27;The answer to life, the universe, and everything!&#x27;);
});
```
...</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-schedule.RecurrenceRule.prototype" id="apidoc.module.node-schedule.RecurrenceRule.prototype">module node-schedule.RecurrenceRule.prototype</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.node-schedule.RecurrenceRule.prototype.nextInvocationDate" id="apidoc.element.node-schedule.RecurrenceRule.prototype.nextInvocationDate">
        function <span class="apidocSignatureSpan">node-schedule.RecurrenceRule.prototype.</span>nextInvocationDate
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextInvocationDate = function (base) {
  base = (base instanceof Date) ? base : (new Date());
  if (!this.recurs) {
    return null;
  }

  var now = new Date();
  var fullYear = now.getFullYear();
  if ((this.year !== null) &#x26;&#x26;
      (typeof this.year == &#x27;number&#x27;) &#x26;&#x26;
      (this.year &#x3c; fullYear)) {
    return null;
  }

  var next = new CronDate(base.getTime());
  next.addSecond();

  while (true) {
    if (this.year !== null) {
      fullYear = next.getFullYear();
      if ((typeof this.year == &#x27;number&#x27;) &#x26;&#x26; (this.year &#x3c; fullYear)) {
        next = null;
        break;
      }

      if (!recurMatch(fullYear, this.year)) {
        next.addYear();
        next.setMonth(0);
        next.setDate(1);
        next.setHours(0);
        next.setMinutes(0);
        next.setSeconds(0);
        continue;
      }
    }
    if (this.month != null &#x26;&#x26; !recurMatch(next.getMonth(), this.month)) {
      next.addMonth();
      continue;
    }
    if (this.date != null &#x26;&#x26; !recurMatch(next.getDate(), this.date)) {
      next.addDay();
      continue;
    }
    if (this.dayOfWeek != null &#x26;&#x26; !recurMatch(next.getDay(), this.dayOfWeek)) {
      next.addDay();
      continue;
    }
    if (this.hour != null &#x26;&#x26; !recurMatch(next.getHours(), this.hour)) {
      next.addHour();
      continue;
    }
    if (this.minute != null &#x26;&#x26; !recurMatch(next.getMinutes(), this.minute)) {
      next.addMinute();
      continue;
    }
    if (this.second != null &#x26;&#x26; !recurMatch(next.getSeconds(), this.second)) {
      next.addSecond();
      continue;
    }

    break;
  }

  return next;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
